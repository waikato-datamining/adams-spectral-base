/*
 *   This program is free software: you can redistribute it and/or modify
 *   it under the terms of the GNU General Public License as published by
 *   the Free Software Foundation, either version 3 of the License, or
 *   (at your option) any later version.
 *
 *   This program is distributed in the hope that it will be useful,
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *   GNU General Public License for more details.
 *
 *   You should have received a copy of the GNU General Public License
 *   along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

/*
 * NIRSpectrumWriter.java
 * Copyright (C) 2010-2025 University of Waikato, Hamilton, New Zealand
 */

package adams.data.io.output;

import adams.core.base.BaseDateTime;
import adams.core.base.BaseFloat;
import adams.core.base.BaseInteger;
import adams.core.io.FileUtils;
import adams.data.io.output.foss.FossOutputHelper.ConstituentValues;
import adams.data.io.output.foss.FossOutputHelper.DataBlock;
import adams.data.io.output.foss.FossOutputHelper.Generalheader;
import adams.data.io.output.foss.FossOutputHelper.InstrumentHeader;
import adams.data.io.output.foss.FossOutputHelper.SampleHeader;
import adams.data.io.output.foss.FossOutputHelper.SampleInfo;
import adams.data.report.DataType;
import adams.data.report.Field;
import adams.data.report.Report;
import adams.data.spectrum.Spectrum;

import java.io.BufferedOutputStream;
import java.io.ByteArrayOutputStream;
import java.io.FileOutputStream;
import java.io.OutputStream;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Collections;
import java.util.Date;
import java.util.List;
import java.util.TimeZone;
import java.util.logging.Level;

/**
<!-- globalinfo-start -->
* Writer that stores spectra in the FOSS .nir Format.
* <br><br>
<!-- globalinfo-end -->
 *
<!-- options-start -->
* Valid options are: <br><br>
*
* <pre>-D &lt;int&gt; (property: debugLevel)
* &nbsp;&nbsp;&nbsp;The greater the number the more additional info the scheme may output to
* &nbsp;&nbsp;&nbsp;the console (0 = off).
* &nbsp;&nbsp;&nbsp;default: 0
* &nbsp;&nbsp;&nbsp;minimum: 0
* </pre>
*
* <pre>-output &lt;adams.core.io.PlaceholderFile&gt; (property: output)
* &nbsp;&nbsp;&nbsp;The file to write the container to.
* &nbsp;&nbsp;&nbsp;default: ${TMP}/out.tmp
* </pre>
*
* <pre>-instrumentName &lt;java.lang.String&gt; (property: instrumentName)
* &nbsp;&nbsp;&nbsp;Instrument Name.
* &nbsp;&nbsp;&nbsp;default: &lt;not implemented&gt;
* </pre>
*
* <pre>-client &lt;java.lang.String&gt; (property: client)
* &nbsp;&nbsp;&nbsp;Client of Sample.
* &nbsp;&nbsp;&nbsp;default: client
* </pre>
*
* <pre>-fileID &lt;java.lang.String&gt; (property: fileID)
* &nbsp;&nbsp;&nbsp;File ID.
* &nbsp;&nbsp;&nbsp;default: generated by ADAMS
* </pre>
*
* <pre>-sampleID1 &lt;java.lang.String&gt; (property: sampleID1)
* &nbsp;&nbsp;&nbsp;Sample ID1.
* &nbsp;&nbsp;&nbsp;default:
* </pre>
*
* <pre>-sampleID2 &lt;java.lang.String&gt; (property: sampleID2)
* &nbsp;&nbsp;&nbsp;Sample ID1.
* &nbsp;&nbsp;&nbsp;default:
* </pre>
*
* <pre>-sampleID3 &lt;java.lang.String&gt; (property: sampleID3)
* &nbsp;&nbsp;&nbsp;Sample ID3.
* &nbsp;&nbsp;&nbsp;default:
* </pre>
*
* <pre>-serialNo &lt;java.lang.String&gt; (property: serialNo)
* &nbsp;&nbsp;&nbsp;Serial Number of Instrument.
* &nbsp;&nbsp;&nbsp;default: 0000-0000-0000
* </pre>
*
* <pre>-master &lt;java.lang.String&gt; (property: master)
* &nbsp;&nbsp;&nbsp;Serial Number of Master Instrument.
* &nbsp;&nbsp;&nbsp;default: 0000-0000-0000
* </pre>
*
* <pre>-operator &lt;java.lang.String&gt; (property: operator)
* &nbsp;&nbsp;&nbsp;Instrument Operator.
* &nbsp;&nbsp;&nbsp;default: ADAMS
* </pre>
*
* <pre>-productCode &lt;java.lang.String&gt; (property: productCode)
* &nbsp;&nbsp;&nbsp;Either the attribute name with the product code in it, or the actual product
* &nbsp;&nbsp;&nbsp;code to be used.
* &nbsp;&nbsp;&nbsp;default: 01
* </pre>
*
* <pre>-productCodeFromField (property: productCodeFromField)
* &nbsp;&nbsp;&nbsp;Regex to find sample id. e.g 'sample_id'
* </pre>
*
* <pre>-segments &lt;adams.core.base.BaseInteger&gt; [-segments ...] (property: segments)
* &nbsp;&nbsp;&nbsp;Segments.
* &nbsp;&nbsp;&nbsp;default: 1050
* </pre>
*
* <pre>-increment &lt;java.lang.Double&gt; (property: increment)
* &nbsp;&nbsp;&nbsp;Increment
* &nbsp;&nbsp;&nbsp;default: 2.0
* </pre>
*
* <pre>-firstXPoint &lt;java.lang.Double&gt; (property: firstXPoint)
* &nbsp;&nbsp;&nbsp;First wavenumber
* &nbsp;&nbsp;&nbsp;default: 3749.3428948242
* </pre>
*
* <pre>-lastXPoint &lt;java.lang.Double&gt; (property: lastXPoint)
* &nbsp;&nbsp;&nbsp;Last wavenumber
* &nbsp;&nbsp;&nbsp;default: 9998.2477195313
* </pre>
*
* <pre>-EOC &lt;java.lang.Integer&gt; (property: EOC)
* &nbsp;&nbsp;&nbsp;Number of EOC's per rev.
* &nbsp;&nbsp;&nbsp;default: 0
* </pre>
*
* <pre>-timestamp &lt;adams.core.base.BaseDateTime&gt; (property: timestamp)
* &nbsp;&nbsp;&nbsp;The timestamp to use in the file; use 'NOW' for current time.
* &nbsp;&nbsp;&nbsp;default: NOW
* </pre>
*
<!-- options-end -->
 *
 * @author  dale (dale at waikato dot ac dot nz)
 */
public class NIRSpectrumWriter
  extends AbstractSpectrumWriter
  implements StreamableBinaryDataContainerWriter<Spectrum> {

  /** for serialization. */
  private static final long serialVersionUID = -95463122424931621L;

  /** File ID. */
  protected String m_FileID;

  /** The instrument name to put in ASC header. */
  protected String m_InstrumentName;

  /** Serial Number of Instrument. */
  protected String m_Serial;

  /** SampleID 1. */
  protected String m_SampleID1;

  /** SampleID 2. */
  protected String m_SampleID2;

  /** SampleID 3. */
  protected String m_SampleID3;

  /** Serial Number of Master Instrument. */
  protected String m_Master;

  /** Either the Field name with the product code in it, or the actual product code. Decided by m_GetProductCodeFromAttribute. */
  protected String m_ProductCode;

  /** Operator name. */
  protected String m_Operator;

  /** Client name. */
  protected String m_Client;

  /** Segment points. */
  protected BaseInteger[] m_Segments;

  /** Segment starting. */
  protected BaseFloat[] m_WaveStarts;

  /** Increments. */
  protected BaseFloat[] m_WaveSteps;

  /** Segment ends. */
  protected BaseFloat[] m_WaveEnds;

  /** Get the product code from the Field named ProductCode in the Report? Otherwise use the ProductCode string directly. */
  protected Boolean m_ProductCodeFromField;

  /** Number of EOC's per rev (???). */
  protected Integer m_EOC;

  /** the timestamp to use in the file. */
  protected BaseDateTime m_Timestamp;

  /**
   * Adds options to the internal list of options.
   */
  @Override
  public void defineOptions() {
    super.defineOptions();

    m_OptionManager.add(
	    "instrumentName", "instrumentName",
	    "<not implemented>");

    m_OptionManager.add(
	    "client", "client",
    	    "client");

    m_OptionManager.add(
	    "fileID", "fileID",
	    "generated by ADAMS");

    m_OptionManager.add(
	    "sampleID1", "sampleID1",
	    "");

    m_OptionManager.add(
	    "sampleID2", "sampleID2",
	    "");

    m_OptionManager.add(
	    "sampleID3", "sampleID3",
	    "");

    m_OptionManager.add(
	    "serialNo", "serialNo",
	    "0000-0000-0000");

    m_OptionManager.add(
	    "master", "master",
	    "0000-0000-0000");

    m_OptionManager.add(
	    "operator", "operator",
	    "ADAMS");

    m_OptionManager.add(
	    "productCode", "productCode",
	    "01");

    m_OptionManager.add(
	    "productCodeFromField", "productCodeFromField",
	    false);

    m_OptionManager.add(
	    "segmentWidths", "segmentWidths",
	    new BaseInteger[]{
		new BaseInteger("1050")});

    m_OptionManager.add(
	    "startPoints", "startPoints",
	    new BaseFloat[]{
		new BaseFloat("400")});

    m_OptionManager.add(
	    "increments", "increments",
	    new BaseFloat[]{
		new BaseFloat("2")});

    m_OptionManager.add(
	    "endPoints", "endPoints",
	    new BaseFloat[]{
		new BaseFloat("1098")});

    m_OptionManager.add(
	    "EOC", "EOC",
	    0);

    m_OptionManager.add(
	    "timestamp", "timestamp",
	    new BaseDateTime(BaseDateTime.NOW));
  }

  /**
   * Get increments.
   * @return increments.
   */
  public BaseFloat[] getIncrements(){
    return(m_WaveSteps);
  }

  /**
   * Set increments.
   * @param in increments.
   */
  public void setIncrements(BaseFloat[] in){
    m_WaveSteps=in;
  }

  /**
   * Returns the tip text for this property.
   *
   * @return 		tip text for this property suitable for
   * 			displaying in the GUI or for listing the options.
   */
  public String incrementsTipText() {
    return "Wave Increments.";
  }


  /**
   * Get end points.
   * @return end points.
   */
  public BaseFloat[] getEndPoints(){
    return(m_WaveEnds);
  }

  /**
   * Set end points.
   * @param ep end points .
   */
  public void setEndPoints(BaseFloat[] ep){
    m_WaveEnds=ep;
  }

  /**
   * Returns the tip text for this property.
   *
   * @return 		tip text for this property suitable for
   * 			displaying in the GUI or for listing the options.
   */
  public String endPointsTipText() {
    return "End points of segments.";
  }

  /**
   * Get start points.
   * @return start points.
   */
  public BaseFloat[] getStartPoints(){
    return(m_WaveStarts);
  }

  /**
   * Set start points.
   * @param sp start points .
   */
  public void setStartPoints(BaseFloat[] sp){
    m_WaveStarts=sp;
  }

  /**
   * Returns the tip text for this property.
   *
   * @return 		tip text for this property suitable for
   * 			displaying in the GUI or for listing the options.
   */
  public String startPointsTipText() {
    return "Start points of segments.";
  }

  /**
   * Get segments.
   * @return segments.
   */
  public BaseInteger[] getSegmentWidths(){
    return(m_Segments);
  }

  /**
   * Set segments.
   * @param segments segments .
   */
  public void setSegmentWidths(BaseInteger[] segments){
    m_Segments=segments;
  }

  /**
   * Returns the tip text for this property.
   *
   * @return 		tip text for this property suitable for
   * 			displaying in the GUI or for listing the options.
   */
  public String segmentWidthsTipText() {
    return "Width of Segments.";
  }



  /**
   * Get product code from instance attribute? Or use as string.
   * @return Get product code from instance attribute?
   */
  public Boolean getProductCodeFromField() {
    return m_ProductCodeFromField;
  }


  /**
   * Set product code from instance attribute? Or use as string.
   * @param mGetProductCodeFromAttribute Set product code from instance attribute?
   */
  public void setProductCodeFromField( Boolean mGetProductCodeFromAttribute) {
    m_ProductCodeFromField = mGetProductCodeFromAttribute;
  }

  /**
   * Returns the tip text for this property.
   *
   * @return 		tip text for this property suitable for
   * 			displaying in the GUI or for listing the options.
   */
  public String productCodeFromFieldTipText() {
    return "Regex to find sample id. e.g 'sample_id'";
  }


  /**
   * Get Product Code.
   * @return	product code
   */
  public String getProductCode(){
    return(m_ProductCode);
  }

  /**
   * Set product code.
   * @param productCode product code.
   */
  public void setProductCode(String productCode){
    m_ProductCode=productCode;
  }

  /**
   * Returns the tip text for this property.
   *
   * @return 		tip text for this property suitable for
   * 			displaying in the GUI or for listing the options.
   */
  public String productCodeTipText() {
    return "Either the attribute name with the product code in it, or the actual product code to be used. ";
  }


  /**
   * Get serial no of master.
   * @return serial no of master.
   */
  public String getMaster() {
    return m_Master;
  }

  /**
   * Set serial no of master.
   *
   * @param serialNo serial no of master.
   */
  public void setMaster(String serialNo) {
    m_Master = serialNo;
  }

  /**
   * Returns the tip text for this property.
   *
   * @return 		tip text for this property suitable for
   * 			displaying in the GUI or for listing the options.
   */
  public String masterTipText() {
    return "Serial Number of Master Instrument.";
  }

  /**
   * Get serial no.
   * @return serial no.
   */
  public String getSerialNo() {
    return m_Serial;
  }

  /**
   * Set serial no.
   *
   * @param serialNo serial no.
   */
  public void setSerialNo(String serialNo) {
    m_Serial = serialNo;
  }

  /**
   * Returns the tip text for this property.
   *
   * @return 		tip text for this property suitable for
   * 			displaying in the GUI or for listing the options.
   */
  public String serialNoTipText() {
    return "Serial Number of Instrument.";
  }
  /**
   * Get client.
   * @return client.
   */
  public String getClient() {
    return m_Client;
  }

  /**
   * Set client.
   *
   * @param client client.
   */
  public void setClient(String client) {
    m_Client = client;
  }

  /**
   * Returns the tip text for this property.
   *
   * @return 		tip text for this property suitable for
   * 			displaying in the GUI or for listing the options.
   */
  public String clientTipText() {
    return "Client of Sample.";
  }

  /**
   * Get operator.
   * @return operator.
   */
  public String getOperator() {
    return m_Operator;
  }

  /**
   * Set operator.
   *
   * @param operator operator.
   */
  public void setOperator(String operator) {
    m_Operator = operator;
  }

  /**
   * Returns the tip text for this property.
   *
   * @return 		tip text for this property suitable for
   * 			displaying in the GUI or for listing the options.
   */
  public String operatorTipText() {
    return "Instrument Operator.";
  }

  /**
   * Get sample id1.
   * @return sample id1.
   */
  public String getSampleID1() {
    return m_SampleID1;
  }

  /**
   * Set sample id1.
   *
   * @param sampleID sampleID1
   */
  public void setSampleID1(String sampleID) {
    m_SampleID1 = sampleID;
  }

  /**
   * Returns the tip text for this property.
   *
   * @return 		tip text for this property suitable for
   * 			displaying in the GUI or for listing the options.
   */
  public String sampleID1TipText() {
    return "Sample ID1.";
  }

  /**
   * Get sample id2.
   * @return sample id2.
   */
  public String getSampleID2() {
    return m_SampleID2;
  }

  /**
   * Set sample id2.
   *
   * @param sampleID sampleID2
   */
  public void setSampleID2(String sampleID) {
    m_SampleID2 = sampleID;
  }

  /**
   * Returns the tip text for this property.
   *
   * @return 		tip text for this property suitable for
   * 			displaying in the GUI or for listing the options.
   */
  public String sampleID2TipText() {
    return "Sample ID1.";
  }

  /**
   * Get sample id3.
   * @return sample id3.
   */
  public String getSampleID3() {
    return m_SampleID3;
  }

  /**
   * Set sample id3.
   *
   * @param sampleID sampleID3
   */
  public void setSampleID3(String sampleID) {
    m_SampleID3 = sampleID;
  }

  /**
   * Returns the tip text for this property.
   *
   * @return 		tip text for this property suitable for
   * 			displaying in the GUI or for listing the options.
   */
  public String sampleID3TipText() {
    return "Sample ID3.";
  }

  /**
   * Get file id.
   * @return file id.
   */
  public String getFileID() {
    return m_FileID;
  }

  /**
   * Set file id.
   *
   * @param fileID file ID
   */
  public void setFileID(String fileID) {
    m_FileID = fileID;
  }

  /**
   * Returns the tip text for this property.
   *
   * @return 		tip text for this property suitable for
   * 			displaying in the GUI or for listing the options.
   */
  public String fileIDTipText() {
    return "File ID.";
  }

  /**
   * Get instrument name.
   *
   * @return instrument name
   */
  public String getInstrumentName() {
    return m_InstrumentName;
  }

  /**
   * Set instrument name.
   *
   * @param mInstrumentName	instrument name
   */
  public void setInstrumentName(String mInstrumentName) {
    m_InstrumentName = mInstrumentName;
  }

  /**
   * Returns the tip text for this property.
   *
   * @return 		tip text for this property suitable for
   * 			displaying in the GUI or for listing the options.
   */
  public String instrumentNameTipText() {
    return "Instrument Name.";
  }

  /**
   * Get number of EOC's per rev (whatever that is!!)
   * @return numbe of EOC's per rev
   */
  public Integer getEOC(){
    return(m_EOC);
  }

  /**
   * Set number of EOC's per rev
   * @param eoc	number of EOC's per rev
   */
  public void setEOC(Integer eoc){
    m_EOC=eoc;
  }

  /**
   * Returns the tip text for this property.
   *
   * @return 		tip text for this property suitable for
   * 			displaying in the GUI or for listing the options.
   */
  public String EOCTipText() {
    return "Number of EOC's per rev.";
  }

  /**
   * Get the timestamp to use in the file.
   *
   * @return 		the timestamp
   */
  public BaseDateTime getTimestamp() {
    return m_Timestamp;
  }

  /**
   * Set the timestamp to use in the file.
   *
   * @param value	the timestamp
   */
  public void setTimestamp(BaseDateTime value) {
    m_Timestamp = value;
  }

  /**
   * Returns the tip text for this property.
   *
   * @return 		tip text for this property suitable for
   * 			displaying in the GUI or for listing the options.
   */
  public String timestampTipText() {
    return "The timestamp to use in the file; use 'NOW' for current time.";
  }

  /**
   * Returns a string describing the object.
   *
   * @return a description suitable for displaying in the gui
   */
  @Override
  public String globalInfo() {
    return "Writer that stores spectra in the FOSS .nir Format.";
  }


  /**
   * Returns a string describing the format (used in the file chooser).
   *
   * @return a description suitable for displaying in the file chooser
   */
  @Override
  public String getFormatDescription() {
    return ".NIR Format";
  }

  /**
   * Returns the extension(s) of the format.
   *
   * @return 		the extension(s) (without the dot!)
   */
  @Override
  public String[] getFormatExtensions() {
    return new String[]{"nir"};
  }

  /**
   * Initializes the members.
   */
  @Override
  protected void initialize() {
    super.initialize();
    m_OutputIsFile = true;
  }

  /**
   * Create GeneralHeader from list of Spectra.
   * @param data	list of Spectra
   * @return		GeneralHeader
   */
  public Generalheader getGeneralHeader(List<Spectrum> data){
    Generalheader gh=new Generalheader();
    gh.m_type = 01; // just an nir file for now
    gh.m_count = data.size();
    gh.m_deleted = 0;
    gh.m_num_points = data.get(0).size();
    gh.m_num_consts = 0;
    Calendar nowhere = Calendar.getInstance();//TimeZone.getTimeZone("Pacific/Auckland"));
    Calendar nowny = Calendar.getInstance(TimeZone.getTimeZone("GMT-4:00"));
    nowhere.setTime(m_Timestamp.dateValue());
    nowny.setTime(m_Timestamp.dateValue());
    String ids[] = TimeZone.getAvailableIDs();
    int millsdiff1=nowhere.get(Calendar.ZONE_OFFSET);
    int millsdiff2=nowny.get(Calendar.ZONE_OFFSET);
    Date date=new Date(nowhere.getTimeInMillis()-millsdiff2+millsdiff1);
    gh.m_creation_date = date;
    gh.m_time = date;
    gh.m_most_recent = 0; //?
    gh.m_file_id = getFileID();
    gh.m_master=getMaster();
    return(gh);
  }

  /**
   * Create InstrumentHeader using parameters.
   * @return	InstrumentHeader
   */
  public InstrumentHeader getInstrumentHeader(){
    InstrumentHeader ih=new InstrumentHeader();
    ih.m_instrument_type=InstrumentHeader.InstrumentType.SIC_6500;
    ih.m_model=getInstrumentName();
    ih.m_serial=getSerialNo();
    ih.m_num_seg=getSegmentWidths().length;
    ih.m_points_per_segment=new int[20];
    for (int i=0;i<ih.m_num_seg;i++){
      ih.m_points_per_segment[i]=getSegmentWidths()[i].intValue();
    }
    ih.m_spacing_mode=01;
    ih.m_wave = new float[21];
    for (int i=0;i<7 && i < m_WaveStarts.length;i++){ // seqment starting points
      ih.m_wave[i] = m_WaveStarts[i].floatValue();
    }
    for (int i=0;i<7 && i < m_WaveSteps.length;i++){ // wave increments
      ih.m_wave[i+7] = m_WaveSteps[i].floatValue();
    }
    for (int i=0;i<7 && i < m_WaveEnds.length;i++){ // segment end points
      ih.m_wave[i+14] = m_WaveEnds[i].floatValue();
    }

    ih.m_neoc=getEOC(); //??
    ih.m_constituents=new String[32];
    for (int i=0;i<32;i++){
      ih.m_constituents[i]="";
    }
    return(ih);
  }

  /**
   * Create a SampleHeader from a Spectrum and position in list/file.
   * @param sp		spectrum
   * @param pos		position
   * @return		SampleHeader
   */
  public SampleHeader getSampleHeader(Spectrum sp, int pos){

    String pcode=m_ProductCode;
    if (m_ProductCodeFromField){
      Report report=sp.getReport();
      if (report==null){
	pcode="<Report Not Available>";
      } else {
	String pcodefield = report.getStringValue(new Field(m_ProductCode, DataType.STRING));
	if (pcodefield == null){
	  pcode="<Field '"+m_ProductCode+"'Not Available in Report>";
	} else {
	  pcode = pcodefield;
	}
      }
    }
    Calendar nowhere = Calendar.getInstance();//TimeZone.getTimeZone("Pacific/Auckland"));
    Calendar nowny = Calendar.getInstance(TimeZone.getTimeZone("GMT-4:00"));
    nowhere.setTime(m_Timestamp.dateValue());
    nowny.setTime(m_Timestamp.dateValue());
    String id=sp.getID().replace("'", "");
    int millsdiff1=nowhere.get(Calendar.ZONE_OFFSET);
    int millsdiff2=nowny.get(Calendar.ZONE_OFFSET);

    Date date=new Date(nowhere.getTimeInMillis()-millsdiff2+millsdiff1);
    SampleHeader sh=new SampleHeader();
    sh.m_sample_no=id;
    sh.m_sequence=pos;
    sh.m_deleted=false;
    sh.m_date=m_Timestamp.dateValue();
    sh.m_time=date;
    // product code!!!!!!!!
    try{
      sh.m_product_code = Integer.valueOf(pcode);
    }catch(Exception e){
      System.err.println("Product code is non-numeric, or not present");
    }
    sh.m_client=getClient();
    sh.m_operator=getOperator();
    sh.m_sample_id1=getSampleID1();
    sh.m_sample_id2=getSampleID2();
    sh.m_sample_id3=getSampleID3();
    sh.m_standardised=0;
    return(sh);
  }

  /**
   * Create a DataBlock from a spectrum.
   * @param sp	spectrum
   * @return	DataBlock
   */
  public DataBlock getDataBlock(Spectrum sp){
    DataBlock db=new DataBlock();
    db.m_Spectrum=sp;
    return(db);
  }

  /**
   * Create ConstituentValues for a spectrum.
   * @param sp	spectrum
   * @return	ConstituentValues
   */
  public ConstituentValues getConstituentValues(Spectrum sp){
    ConstituentValues cv=new ConstituentValues();
    cv.m_Constituents=null;
    return(cv);
  }

  /**
   * Create a SampleInfo for the file footer based on a Spectrum and it's position in list/file.
   * @param sp		Spectrum
   * @param pos		position
   * @return		SampleInfo
   */
  public SampleInfo getSampleInfo(Spectrum sp,int pos){
    SampleInfo si=new SampleInfo();
    si.m_deleted=false;
    si.m_sample_id= sp.getID().replace("'", "");
    si.m_sequence=pos;
    return(si);
  }

  /**
   * Generate the byte array that makes up the .nir file.
   *
   * @param datalist	the Spectra to write.
   * @return 		byte array.
   */
  protected byte[] genByteArray(List<Spectrum> datalist) throws Exception{
    ByteArrayOutputStream outStream = new ByteArrayOutputStream();
    Generalheader gh=getGeneralHeader(datalist);
    outStream.write(gh.getBytes());
    InstrumentHeader ih=getInstrumentHeader();
    outStream.write(ih.getBytes());
    for (int i=0;i<datalist.size();i++){
      Spectrum sp=datalist.get(i);
      SampleHeader sh=getSampleHeader( sp, i);
      outStream.write(sh.getBytes());
      DataBlock db=getDataBlock(sp);
      outStream.write(db.getBytes());
      ConstituentValues cv=getConstituentValues(sp);
      outStream.write(cv.getBytes());
    }

    for (int i=0;i<datalist.size();i++){
      Spectrum sp=datalist.get(i);
      SampleInfo si=getSampleInfo( sp, i);
      outStream.write(si.getBytes());
    }
    return(outStream.toByteArray());
  }

  /**
   * Generate the byte array that makes up the .nir file.
   *
   * @param data	the data to write
   * @return 		ASC file as string.
   */
  protected byte[] genByteArray(Spectrum data){

    String pcode=m_ProductCode;
    if (m_ProductCodeFromField){
      Report report=data.getReport();
      if (report==null){
	pcode="<Report Not Available>";
      } else {
	String pcodefield = report.getStringValue(new Field(m_ProductCode, DataType.STRING));
	if (pcodefield == null){
	  pcode="<Field '"+m_ProductCode+"'Not Available in Report>";
	} else {
	  pcode = pcodefield;
	}
      }
    }
    String id=data.getID().replace("'", "");

    Generalheader gh=new Generalheader();
    gh.m_type = 01; // just an nir file for now
    gh.m_count = 1;
    gh.m_deleted = 0;
    gh.m_num_points = data.size();
    gh.m_num_consts = 0;
    Calendar nowhere = Calendar.getInstance();//TimeZone.getTimeZone("Pacific/Auckland"));
    Calendar nowny = Calendar.getInstance(TimeZone.getTimeZone("GMT-4:00"));
    nowhere.setTime(m_Timestamp.dateValue());
    nowny.setTime(m_Timestamp.dateValue());
    String[] ids = TimeZone.getAvailableIDs();
    int millsdiff1=nowhere.get(Calendar.ZONE_OFFSET);
    int millsdiff2=nowny.get(Calendar.ZONE_OFFSET);

    Date date=new Date(nowhere.getTimeInMillis()-millsdiff2+millsdiff1);
    gh.m_creation_date = date;
    gh.m_time = date;
    gh.m_most_recent = 0; //?
    gh.m_file_id = getFileID();
    gh.m_master=getMaster();

    InstrumentHeader ih=new InstrumentHeader();
    ih.m_instrument_type=InstrumentHeader.InstrumentType.SIC_6500;
    ih.m_model=getInstrumentName();
    ih.m_serial=getSerialNo();
    ih.m_num_seg=getSegmentWidths().length;
    ih.m_points_per_segment=new int[20];
    for (int i=0;i<ih.m_num_seg;i++){
      ih.m_points_per_segment[i]=getSegmentWidths()[i].intValue();
    }
    ih.m_spacing_mode=01;
    ih.m_wave = new float[21];

    for (int i=0;i<7 && i < m_WaveStarts.length;i++){ // seqment starting points
      ih.m_wave[i] = m_WaveStarts[i].floatValue();
    }
    for (int i=0;i<7 && i < m_WaveSteps.length;i++){ // wave increments
      ih.m_wave[i+7] = m_WaveSteps[i].floatValue();
    }
    for (int i=0;i<7 && i < m_WaveEnds.length;i++){ // segment end points
      ih.m_wave[i+14] = m_WaveEnds[i].floatValue();
    }

    ih.m_neoc=getEOC(); //??
    ih.m_constituents=new String[32];
    for (int i=0;i<32;i++){
      ih.m_constituents[i]="";
    }

    SampleHeader sh=new SampleHeader();
    sh.m_sample_no=id;
    sh.m_sequence=0;
    sh.m_deleted=false;
    sh.m_date=m_Timestamp.dateValue();
    sh.m_time=date;
    // product code!!!!!!!!
    try{
      sh.m_product_code = Integer.valueOf(pcode);
    }catch(Exception e){
      System.err.println("Product code is non-numeric, or not present");
    }
    sh.m_client="client";
    sh.m_operator=getOperator();
    sh.m_sample_id1=getSampleID1();
    sh.m_sample_id2=getSampleID2();
    sh.m_sample_id3=getSampleID3();
    sh.m_standardised=0;

    DataBlock db=new DataBlock();
    db.m_Spectrum=data;

    SampleInfo si=new SampleInfo();
    si.m_deleted=false;
    si.m_sample_id=id;
    si.m_sequence=0;

    ConstituentValues cv=new ConstituentValues();
    cv.m_Constituents=null;

    ByteArrayOutputStream outStream = new ByteArrayOutputStream();
    try{
      outStream.write(gh.getBytes());
      outStream.write(ih.getBytes());
      outStream.write(sh.getBytes());
      outStream.write(db.getBytes());
      outStream.write(cv.getBytes());
      outStream.write(si.getBytes());
      return(outStream.toByteArray());
    }catch(Exception e){
      getLogger().log(Level.SEVERE, "Failed to write data!", e);
      return(null);
    }
  }
  
  /**
   * Returns whether writing of multiple containers is supported.
   * 
   * @return 		true if multiple containers are supported
   */
  @Override
  public boolean canWriteMultiple() {
    return true;
  }

  /**
   * Performs the actual writing.
   *
   * @param data	the data to write
   * @return		success
   */
  @Override
  protected boolean writeData(List<Spectrum> data) {
    BufferedOutputStream writer = null;
    FileOutputStream fos = null;
    try {
      byte[] bytes=genByteArray(data);
      if (bytes != null){
        fos = new FileOutputStream(m_Output.getAbsolutePath());
	writer = new BufferedOutputStream(fos);
	writer.write(bytes);
	return true;
      }
      return(false);
    }catch (Exception e) {
      getLogger().log(Level.SEVERE, "Failed to write data to: " + m_Output, e);
      return false;
    }
    finally {
      FileUtils.closeQuietly(writer);
      FileUtils.closeQuietly(fos);
    }
  }

  /**
   * Performs checks and writes the data to the stream.
   *
   * @param stream the stream to write to
   * @param data   the data to write
   * @return true if successfully written
   * @see                #write(OutputStream stream, List)
   */
  @Override
  public boolean write(OutputStream stream, Spectrum data) {
    return write(stream, new ArrayList<>(Collections.singletonList(data)));
  }

  /**
   * Performs checks and writes the data to the stream.
   *
   * @param stream the stream to write to
   * @param data   the data to write
   * @return true if successfully written
   */
  @Override
  public boolean write(OutputStream stream, List<Spectrum> data) {
    try {
      stream.write(genByteArray(data));
      return true;
    }
    catch (Exception e) {
      getLogger().log(Level.SEVERE, "Failed to write data to stream!", e);
      return false;
    }
  }
}
